{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-axios",
  "type": "registry:hook",
  "title": "UseAxios",
  "description": "A customizable hook for making HTTP requests with Axios",
  "files": [
    {
      "path": "registry/hooks/use-axios.tsx",
      "content": "'use client';\n\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nimport axios, {\n  AxiosError,\n  AxiosInstance,\n  AxiosRequestConfig,\n  AxiosResponse,\n} from 'axios';\n\n// Types\nexport interface UseAxiosProps {\n  baseURL?: string;\n  headers?: Record<string, string>;\n  timeout?: number;\n  config?: AxiosRequestConfig;\n  interceptors?: AxiosInterceptors;\n}\n\nexport interface AxiosInterceptors {\n  request?: {\n    onFulfilled?: (\n      config: AxiosRequestConfig,\n    ) => AxiosRequestConfig | Promise<AxiosRequestConfig>;\n    onRejected?: (error: AxiosError) => void;\n  };\n  response?: {\n    onFulfilled?: (\n      response: AxiosResponse,\n    ) => AxiosResponse | Promise<AxiosResponse>;\n    onRejected?: (error: AxiosError) => void;\n  };\n}\n\nexport interface UseAxiosReturn<TData = void> {\n  instance: AxiosInstance;\n  loading: boolean;\n  error: AxiosError | null;\n  data: TData | null;\n  get: <TReturn = TData>(\n    url: string,\n    config?: AxiosRequestConfig,\n  ) => Promise<AxiosResponse<TReturn>>;\n  post: <TReturn = TData, TBody = void>(\n    url: string,\n    data?: TBody,\n    config?: AxiosRequestConfig,\n  ) => Promise<AxiosResponse<TReturn>>;\n  put: <TReturn = TData, TBody = void>(\n    url: string,\n    data?: TBody,\n    config?: AxiosRequestConfig,\n  ) => Promise<AxiosResponse<TReturn>>;\n  delete: <TReturn = TData>(\n    url: string,\n    config?: AxiosRequestConfig,\n  ) => Promise<AxiosResponse<TReturn>>;\n  patch: <TReturn = TData, TBody = void>(\n    url: string,\n    data?: TBody,\n    config?: AxiosRequestConfig,\n  ) => Promise<AxiosResponse<TReturn>>;\n  setHeaders: (headers: Record<string, string>) => void;\n  /** Reset headers to an empty object */\n  resetHeaders: () => void;\n  /** Reset base URL to the current prop value */\n  resetBaseURL: () => void;\n  setInterceptors: (interceptors: AxiosInterceptors) => void;\n  /** Reset interceptors to the current prop value */\n  resetInterceptors: () => void;\n  cancelRequest: () => void;\n  resetError: () => void;\n  resetData: () => void;\n  setBaseURL: (url: string) => void;\n  /** Update the default request timeout */\n  setTimeout: (ms: number) => void;\n  /** Reset the request timeout to the current prop value */\n  resetTimeout: () => void;\n  /** Merge additional Axios configuration options */\n  setConfig: (config: AxiosRequestConfig) => void;\n  /** Reset the Axios config to the current prop value */\n  resetConfig: () => void;\n}\n\nexport function useAxios<TData = void>({\n  baseURL = '',\n  headers = {},\n  timeout = 10000,\n  config = {},\n  interceptors,\n}: UseAxiosProps = {}): UseAxiosReturn<TData> {\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<AxiosError | null>(null);\n  const [data, setData] = useState<TData | null>(null);\n  const [baseURLState, setBaseURLState] = useState(baseURL);\n  const [timeoutState, setTimeoutState] = useState(timeout);\n  const [configState, setConfigState] = useState(config);\n  const [headersState, setHeadersState] = useState(headers);\n\n  // Sync baseURL prop changes\n  useEffect(() => {\n    setBaseURLState(baseURL);\n  }, [baseURL]);\n\n  useEffect(() => {\n    setTimeoutState(timeout);\n  }, [timeout]);\n\n  useEffect(() => {\n    setConfigState(config);\n  }, [config]);\n\n  useEffect(() => {\n    setHeadersState(headers);\n  }, [headers]);\n  const [interceptorsState, setInterceptorsState] = useState<\n    AxiosInterceptors | undefined\n  >(interceptors);\n\n  // Create a ref to store the axios instance to prevent recreation on each render\n  const instanceRef = useRef<AxiosInstance | null>(null);\n  const controllerRef = useRef<AbortController | null>(null);\n\n  // Initialize axios instance\n  useEffect(() => {\n    const instance = axios.create({\n      baseURL: baseURLState,\n      headers: headersState,\n      timeout: timeoutState,\n      ...configState,\n    });\n\n    if (interceptorsState?.request) {\n      instance.interceptors.request.use(\n        interceptorsState.request.onFulfilled,\n        interceptorsState.request.onRejected,\n      );\n    }\n\n    if (interceptorsState?.response) {\n      instance.interceptors.response.use(\n        interceptorsState.response.onFulfilled,\n        interceptorsState.response.onRejected,\n      );\n    }\n\n    instanceRef.current = instance;\n\n    return () => {\n      controllerRef.current?.abort();\n      instanceRef.current = null;\n      controllerRef.current = null;\n    };\n  }, [\n    baseURLState,\n    headersState,\n    timeoutState,\n    configState,\n    interceptorsState,\n  ]);\n\n  // Get the current instance\n  const getInstance = useCallback((): AxiosInstance => {\n    if (!instanceRef.current) {\n      const instance = axios.create({\n        baseURL: baseURLState,\n        headers: headersState,\n        timeout: timeoutState,\n        ...configState,\n      });\n\n      if (interceptorsState?.request) {\n        instance.interceptors.request.use(\n          interceptorsState.request.onFulfilled,\n          interceptorsState.request.onRejected,\n        );\n      }\n\n      if (interceptorsState?.response) {\n        instance.interceptors.response.use(\n          interceptorsState.response.onFulfilled,\n          interceptorsState.response.onRejected,\n        );\n      }\n\n      instanceRef.current = instance;\n    }\n    return instanceRef.current;\n  }, [\n    baseURLState,\n    headersState,\n    timeoutState,\n    configState,\n    interceptorsState,\n  ]);\n\n  // Helper to handle request execution\n  const executeRequest = useCallback(\n    async <TReturn = TData, TBody = void>(\n      method: string,\n      url: string,\n      data?: TBody,\n      customConfig?: AxiosRequestConfig,\n    ): Promise<AxiosResponse<TReturn>> => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        const instance = getInstance();\n        const controller = new AbortController();\n        controllerRef.current = controller;\n\n        const response = await instance.request<TReturn>({\n          method,\n          url,\n          data,\n          signal: controller.signal,\n          ...customConfig,\n        });\n\n        setData(response.data as TData);\n        return response;\n      } catch (err) {\n        const axiosError = err as AxiosError;\n        setError(axiosError);\n        throw axiosError;\n      } finally {\n        setLoading(false);\n        controllerRef.current = null;\n      }\n    },\n    [getInstance],\n  );\n\n  // Request methods\n  const get = useCallback(\n    <TReturn = TData,>(url: string, config?: AxiosRequestConfig) => {\n      return executeRequest<TReturn>('get', url, undefined, config);\n    },\n    [executeRequest],\n  );\n\n  const post = useCallback(\n    <TReturn = TData, TBody = void>(\n      url: string,\n      data?: TBody,\n      config?: AxiosRequestConfig,\n    ) => {\n      return executeRequest<TReturn>('post', url, data, config);\n    },\n    [executeRequest],\n  );\n\n  const put = useCallback(\n    <TReturn = TData, TBody = void>(\n      url: string,\n      data?: TBody,\n      config?: AxiosRequestConfig,\n    ) => {\n      return executeRequest<TReturn>('put', url, data, config);\n    },\n    [executeRequest],\n  );\n\n  const del = useCallback(\n    <TReturn = TData,>(url: string, config?: AxiosRequestConfig) => {\n      return executeRequest<TReturn>('delete', url, undefined, config);\n    },\n    [executeRequest],\n  );\n\n  const patch = useCallback(\n    <TReturn = TData, TBody = void>(\n      url: string,\n      data?: TBody,\n      config?: AxiosRequestConfig,\n    ) => {\n      return executeRequest<TReturn>('patch', url, data, config);\n    },\n    [executeRequest],\n  );\n\n  const setHeaders = useCallback(\n    (newHeaders: Record<string, string>) => {\n      setHeadersState((prev) => ({\n        ...prev,\n        ...newHeaders,\n      }));\n\n      const instance = getInstance();\n      instance.defaults.headers = {\n        ...instance.defaults.headers,\n        ...newHeaders,\n      } as Record<string, string>;\n    },\n    [getInstance],\n  );\n\n  const resetHeaders = useCallback(() => {\n    setHeadersState({});\n\n    const instance = getInstance();\n    instance.defaults.headers = {} as Record<string, string>;\n  }, [getInstance]);\n\n  const setInterceptors = useCallback((next: AxiosInterceptors) => {\n    setInterceptorsState(next);\n  }, []);\n\n  const resetInterceptors = useCallback(() => {\n    setInterceptorsState(interceptors);\n  }, [interceptors]);\n\n  const resetBaseURL = useCallback(() => {\n    setBaseURLState(baseURL);\n\n    const instance = getInstance();\n    instance.defaults.baseURL = baseURL;\n  }, [baseURL, getInstance]);\n\n  const cancelRequest = useCallback(() => {\n    controllerRef.current?.abort();\n    controllerRef.current = null;\n  }, []);\n\n  const resetError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  const resetData = useCallback(() => {\n    setData(null);\n  }, []);\n\n  const setBaseURL = useCallback((url: string) => {\n    setBaseURLState(url);\n  }, []);\n\n  const setTimeout = useCallback((ms: number) => {\n    setTimeoutState(ms);\n  }, []);\n\n  const resetTimeout = useCallback(() => {\n    setTimeoutState(timeout);\n\n    const instance = getInstance();\n    instance.defaults.timeout = timeout;\n  }, [timeout, getInstance]);\n\n  const setConfig = useCallback((next: AxiosRequestConfig) => {\n    setConfigState((prev) => ({\n      ...prev,\n      ...next,\n    }));\n  }, []);\n\n  const resetConfig = useCallback(() => {\n    setConfigState(config);\n\n    const instance = getInstance();\n    Object.assign(instance.defaults, config);\n  }, [config, getInstance]);\n\n  return {\n    instance: getInstance(),\n    loading,\n    error,\n    data,\n    get,\n    post,\n    put,\n    delete: del,\n    patch,\n    setHeaders,\n    resetHeaders,\n    resetBaseURL,\n    setInterceptors,\n    resetInterceptors,\n    cancelRequest,\n    resetError,\n    resetData,\n    setBaseURL,\n    setTimeout,\n    resetTimeout,\n    setConfig,\n    resetConfig,\n  };\n}\n",
      "type": "registry:hook",
      "target": "hooks/guarahooks/use-axios.tsx"
    }
  ],
  "categories": ["utilities"]
}
